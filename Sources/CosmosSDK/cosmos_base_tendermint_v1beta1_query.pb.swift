// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/base/tendermint/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GetValidatorSetByHeightRequest is the request type for the Query/GetValidatorSetByHeight RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  /// pagination defines an pagination for the request.
  public var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockHeight: Int64 = 0

  public var validators: [Cosmos_Base_Tendermint_V1beta1_Validator] = []

  /// pagination defines an pagination for the response.
  public var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// GetLatestValidatorSetRequest is the request type for the Query/GetValidatorSetByHeight RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines an pagination for the request.
  public var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockHeight: Int64 = 0

  public var validators: [Cosmos_Base_Tendermint_V1beta1_Validator] = []

  /// pagination defines an pagination for the response.
  public var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// Validator is the type for the validator-set.
public struct Cosmos_Base_Tendermint_V1beta1_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var pubKey: SwiftProtobuf.Google_Protobuf_Any {
    get {return _pubKey ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  public var hasPubKey: Bool {return self._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  public mutating func clearPubKey() {self._pubKey = nil}

  public var votingPower: Int64 = 0

  public var proposerPriority: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pubKey: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// GetBlockByHeightRequest is the request type for the Query/GetBlockByHeight RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockID: Tendermint_Types_BlockID {
    get {return _storage._blockID ?? Tendermint_Types_BlockID()}
    set {_uniqueStorage()._blockID = newValue}
  }
  /// Returns true if `blockID` has been explicitly set.
  public var hasBlockID: Bool {return _storage._blockID != nil}
  /// Clears the value of `blockID`. Subsequent reads from it will return its default value.
  public mutating func clearBlockID() {_uniqueStorage()._blockID = nil}

  /// Deprecated: please use `sdk_block` instead
  public var block: Tendermint_Types_Block {
    get {return _storage._block ?? Tendermint_Types_Block()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {_uniqueStorage()._block = nil}

  /// Since: cosmos-sdk 0.47
  public var sdkBlock: Cosmos_Base_Tendermint_V1beta1_Block {
    get {return _storage._sdkBlock ?? Cosmos_Base_Tendermint_V1beta1_Block()}
    set {_uniqueStorage()._sdkBlock = newValue}
  }
  /// Returns true if `sdkBlock` has been explicitly set.
  public var hasSdkBlock: Bool {return _storage._sdkBlock != nil}
  /// Clears the value of `sdkBlock`. Subsequent reads from it will return its default value.
  public mutating func clearSdkBlock() {_uniqueStorage()._sdkBlock = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GetLatestBlockRequest is the request type for the Query/GetLatestBlock RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetLatestBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetLatestBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockID: Tendermint_Types_BlockID {
    get {return _storage._blockID ?? Tendermint_Types_BlockID()}
    set {_uniqueStorage()._blockID = newValue}
  }
  /// Returns true if `blockID` has been explicitly set.
  public var hasBlockID: Bool {return _storage._blockID != nil}
  /// Clears the value of `blockID`. Subsequent reads from it will return its default value.
  public mutating func clearBlockID() {_uniqueStorage()._blockID = nil}

  /// Deprecated: please use `sdk_block` instead
  public var block: Tendermint_Types_Block {
    get {return _storage._block ?? Tendermint_Types_Block()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {_uniqueStorage()._block = nil}

  /// Since: cosmos-sdk 0.47
  public var sdkBlock: Cosmos_Base_Tendermint_V1beta1_Block {
    get {return _storage._sdkBlock ?? Cosmos_Base_Tendermint_V1beta1_Block()}
    set {_uniqueStorage()._sdkBlock = newValue}
  }
  /// Returns true if `sdkBlock` has been explicitly set.
  public var hasSdkBlock: Bool {return _storage._sdkBlock != nil}
  /// Clears the value of `sdkBlock`. Subsequent reads from it will return its default value.
  public mutating func clearSdkBlock() {_uniqueStorage()._sdkBlock = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GetSyncingRequest is the request type for the Query/GetSyncing RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetSyncingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetSyncingResponse is the response type for the Query/GetSyncing RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetSyncingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var syncing: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetNodeInfoRequest is the request type for the Query/GetNodeInfo RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetNodeInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method.
public struct Cosmos_Base_Tendermint_V1beta1_GetNodeInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var defaultNodeInfo: Tendermint_P2p_DefaultNodeInfo {
    get {return _storage._defaultNodeInfo ?? Tendermint_P2p_DefaultNodeInfo()}
    set {_uniqueStorage()._defaultNodeInfo = newValue}
  }
  /// Returns true if `defaultNodeInfo` has been explicitly set.
  public var hasDefaultNodeInfo: Bool {return _storage._defaultNodeInfo != nil}
  /// Clears the value of `defaultNodeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultNodeInfo() {_uniqueStorage()._defaultNodeInfo = nil}

  public var applicationVersion: Cosmos_Base_Tendermint_V1beta1_VersionInfo {
    get {return _storage._applicationVersion ?? Cosmos_Base_Tendermint_V1beta1_VersionInfo()}
    set {_uniqueStorage()._applicationVersion = newValue}
  }
  /// Returns true if `applicationVersion` has been explicitly set.
  public var hasApplicationVersion: Bool {return _storage._applicationVersion != nil}
  /// Clears the value of `applicationVersion`. Subsequent reads from it will return its default value.
  public mutating func clearApplicationVersion() {_uniqueStorage()._applicationVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// VersionInfo is the type for the GetNodeInfoResponse message.
public struct Cosmos_Base_Tendermint_V1beta1_VersionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var appName: String = String()

  public var version: String = String()

  public var gitCommit: String = String()

  public var buildTags: String = String()

  public var goVersion: String = String()

  public var buildDeps: [Cosmos_Base_Tendermint_V1beta1_Module] = []

  /// Since: cosmos-sdk 0.43
  public var cosmosSdkVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Module is the type for VersionInfo
public struct Cosmos_Base_Tendermint_V1beta1_Module {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// module path
  public var path: String = String()

  /// module version
  public var version: String = String()

  /// checksum
  public var sum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ABCIQueryRequest defines the request structure for the ABCIQuery gRPC query.
public struct Cosmos_Base_Tendermint_V1beta1_ABCIQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var path: String = String()

  public var height: Int64 = 0

  public var prove: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.
///
/// Note: This type is a duplicate of the ResponseQuery proto type defined in
/// Tendermint.
public struct Cosmos_Base_Tendermint_V1beta1_ABCIQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: UInt32 = 0

  /// nondeterministic
  public var log: String = String()

  /// nondeterministic
  public var info: String = String()

  public var index: Int64 = 0

  public var key: Data = Data()

  public var value: Data = Data()

  public var proofOps: Cosmos_Base_Tendermint_V1beta1_ProofOps {
    get {return _proofOps ?? Cosmos_Base_Tendermint_V1beta1_ProofOps()}
    set {_proofOps = newValue}
  }
  /// Returns true if `proofOps` has been explicitly set.
  public var hasProofOps: Bool {return self._proofOps != nil}
  /// Clears the value of `proofOps`. Subsequent reads from it will return its default value.
  public mutating func clearProofOps() {self._proofOps = nil}

  public var height: Int64 = 0

  public var codespace: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _proofOps: Cosmos_Base_Tendermint_V1beta1_ProofOps? = nil
}

/// ProofOp defines an operation used for calculating Merkle root. The data could
/// be arbitrary format, providing necessary data for example neighbouring node
/// hash.
///
/// Note: This type is a duplicate of the ProofOp proto type defined in Tendermint.
public struct Cosmos_Base_Tendermint_V1beta1_ProofOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var key: Data = Data()

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ProofOps is Merkle proof defined by the list of ProofOps.
///
/// Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
public struct Cosmos_Base_Tendermint_V1beta1_ProofOps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ops: [Cosmos_Base_Tendermint_V1beta1_ProofOp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightRequest: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightResponse: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetRequest: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetResponse: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_Validator: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightRequest: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightResponse: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetLatestBlockRequest: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetLatestBlockResponse: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetSyncingRequest: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetSyncingResponse: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetNodeInfoRequest: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_GetNodeInfoResponse: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_VersionInfo: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_Module: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_ABCIQueryRequest: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_ABCIQueryResponse: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_ProofOp: @unchecked Sendable {}
extension Cosmos_Base_Tendermint_V1beta1_ProofOps: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.base.tendermint.v1beta1"

extension Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetValidatorSetByHeightRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightRequest, rhs: Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetValidatorSetByHeightResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .same(proto: "validators"),
    3: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blockHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightResponse, rhs: Cosmos_Base_Tendermint_V1beta1_GetValidatorSetByHeightResponse) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLatestValidatorSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetRequest, rhs: Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLatestValidatorSetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .same(proto: "validators"),
    3: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blockHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetResponse, rhs: Cosmos_Base_Tendermint_V1beta1_GetLatestValidatorSetResponse) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Validator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "pub_key"),
    3: .standard(proto: "voting_power"),
    4: .standard(proto: "proposer_priority"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pubKey) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.votingPower) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.proposerPriority) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._pubKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.votingPower != 0 {
      try visitor.visitSingularInt64Field(value: self.votingPower, fieldNumber: 3)
    }
    if self.proposerPriority != 0 {
      try visitor.visitSingularInt64Field(value: self.proposerPriority, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_Validator, rhs: Cosmos_Base_Tendermint_V1beta1_Validator) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._pubKey != rhs._pubKey {return false}
    if lhs.votingPower != rhs.votingPower {return false}
    if lhs.proposerPriority != rhs.proposerPriority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBlockByHeightRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightRequest, rhs: Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightRequest) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBlockByHeightResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_id"),
    2: .same(proto: "block"),
    3: .standard(proto: "sdk_block"),
  ]

  fileprivate class _StorageClass {
    var _blockID: Tendermint_Types_BlockID? = nil
    var _block: Tendermint_Types_Block? = nil
    var _sdkBlock: Cosmos_Base_Tendermint_V1beta1_Block? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _blockID = source._blockID
      _block = source._block
      _sdkBlock = source._sdkBlock
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._blockID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._block) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sdkBlock) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._blockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sdkBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightResponse, rhs: Cosmos_Base_Tendermint_V1beta1_GetBlockByHeightResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._blockID != rhs_storage._blockID {return false}
        if _storage._block != rhs_storage._block {return false}
        if _storage._sdkBlock != rhs_storage._sdkBlock {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetLatestBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLatestBlockRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetLatestBlockRequest, rhs: Cosmos_Base_Tendermint_V1beta1_GetLatestBlockRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetLatestBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLatestBlockResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_id"),
    2: .same(proto: "block"),
    3: .standard(proto: "sdk_block"),
  ]

  fileprivate class _StorageClass {
    var _blockID: Tendermint_Types_BlockID? = nil
    var _block: Tendermint_Types_Block? = nil
    var _sdkBlock: Cosmos_Base_Tendermint_V1beta1_Block? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _blockID = source._blockID
      _block = source._block
      _sdkBlock = source._sdkBlock
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._blockID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._block) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sdkBlock) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._blockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sdkBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetLatestBlockResponse, rhs: Cosmos_Base_Tendermint_V1beta1_GetLatestBlockResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._blockID != rhs_storage._blockID {return false}
        if _storage._block != rhs_storage._block {return false}
        if _storage._sdkBlock != rhs_storage._sdkBlock {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetSyncingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSyncingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetSyncingRequest, rhs: Cosmos_Base_Tendermint_V1beta1_GetSyncingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetSyncingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSyncingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "syncing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.syncing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.syncing != false {
      try visitor.visitSingularBoolField(value: self.syncing, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetSyncingResponse, rhs: Cosmos_Base_Tendermint_V1beta1_GetSyncingResponse) -> Bool {
    if lhs.syncing != rhs.syncing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetNodeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNodeInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetNodeInfoRequest, rhs: Cosmos_Base_Tendermint_V1beta1_GetNodeInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_GetNodeInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNodeInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_node_info"),
    2: .standard(proto: "application_version"),
  ]

  fileprivate class _StorageClass {
    var _defaultNodeInfo: Tendermint_P2p_DefaultNodeInfo? = nil
    var _applicationVersion: Cosmos_Base_Tendermint_V1beta1_VersionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _defaultNodeInfo = source._defaultNodeInfo
      _applicationVersion = source._applicationVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._defaultNodeInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._applicationVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._defaultNodeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._applicationVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_GetNodeInfoResponse, rhs: Cosmos_Base_Tendermint_V1beta1_GetNodeInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._defaultNodeInfo != rhs_storage._defaultNodeInfo {return false}
        if _storage._applicationVersion != rhs_storage._applicationVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_VersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "app_name"),
    3: .same(proto: "version"),
    4: .standard(proto: "git_commit"),
    5: .standard(proto: "build_tags"),
    6: .standard(proto: "go_version"),
    7: .standard(proto: "build_deps"),
    8: .standard(proto: "cosmos_sdk_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gitCommit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.buildTags) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.goVersion) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.buildDeps) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.cosmosSdkVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.gitCommit.isEmpty {
      try visitor.visitSingularStringField(value: self.gitCommit, fieldNumber: 4)
    }
    if !self.buildTags.isEmpty {
      try visitor.visitSingularStringField(value: self.buildTags, fieldNumber: 5)
    }
    if !self.goVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.goVersion, fieldNumber: 6)
    }
    if !self.buildDeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buildDeps, fieldNumber: 7)
    }
    if !self.cosmosSdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.cosmosSdkVersion, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_VersionInfo, rhs: Cosmos_Base_Tendermint_V1beta1_VersionInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.appName != rhs.appName {return false}
    if lhs.version != rhs.version {return false}
    if lhs.gitCommit != rhs.gitCommit {return false}
    if lhs.buildTags != rhs.buildTags {return false}
    if lhs.goVersion != rhs.goVersion {return false}
    if lhs.buildDeps != rhs.buildDeps {return false}
    if lhs.cosmosSdkVersion != rhs.cosmosSdkVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_Module: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Module"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "version"),
    3: .same(proto: "sum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.sum.isEmpty {
      try visitor.visitSingularStringField(value: self.sum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_Module, rhs: Cosmos_Base_Tendermint_V1beta1_Module) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.version != rhs.version {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_ABCIQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ABCIQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "path"),
    3: .same(proto: "height"),
    4: .same(proto: "prove"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.prove) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    if self.prove != false {
      try visitor.visitSingularBoolField(value: self.prove, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_ABCIQueryRequest, rhs: Cosmos_Base_Tendermint_V1beta1_ABCIQueryRequest) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.path != rhs.path {return false}
    if lhs.height != rhs.height {return false}
    if lhs.prove != rhs.prove {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_ABCIQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ABCIQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .same(proto: "log"),
    4: .same(proto: "info"),
    5: .same(proto: "index"),
    6: .same(proto: "key"),
    7: .same(proto: "value"),
    8: .standard(proto: "proof_ops"),
    9: .same(proto: "height"),
    10: .same(proto: "codespace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._proofOps) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 5)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 6)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 7)
    }
    try { if let v = self._proofOps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 9)
    }
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_ABCIQueryResponse, rhs: Cosmos_Base_Tendermint_V1beta1_ABCIQueryResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.log != rhs.log {return false}
    if lhs.info != rhs.info {return false}
    if lhs.index != rhs.index {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._proofOps != rhs._proofOps {return false}
    if lhs.height != rhs.height {return false}
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_ProofOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProofOp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "key"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_ProofOp, rhs: Cosmos_Base_Tendermint_V1beta1_ProofOp) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.key != rhs.key {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Tendermint_V1beta1_ProofOps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProofOps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ops"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ops) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ops, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cosmos_Base_Tendermint_V1beta1_ProofOps, rhs: Cosmos_Base_Tendermint_V1beta1_ProofOps) -> Bool {
    if lhs.ops != rhs.ops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
