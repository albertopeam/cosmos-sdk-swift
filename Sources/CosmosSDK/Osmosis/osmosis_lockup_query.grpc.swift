//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: osmosis/lockup/query.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


/// Query defines the gRPC querier service.
///
/// Usage: instantiate `Osmosis_Lockup_QueryClient`, then call methods of this protocol to make API calls.
public protocol Osmosis_Lockup_QueryClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol? { get }

  func moduleBalance(
    _ request: Osmosis_Lockup_ModuleBalanceRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_ModuleBalanceRequest, Osmosis_Lockup_ModuleBalanceResponse>

  func moduleLockedAmount(
    _ request: Osmosis_Lockup_ModuleLockedAmountRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_ModuleLockedAmountRequest, Osmosis_Lockup_ModuleLockedAmountResponse>

  func accountUnlockableCoins(
    _ request: Osmosis_Lockup_AccountUnlockableCoinsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountUnlockableCoinsRequest, Osmosis_Lockup_AccountUnlockableCoinsResponse>

  func accountUnlockingCoins(
    _ request: Osmosis_Lockup_AccountUnlockingCoinsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountUnlockingCoinsRequest, Osmosis_Lockup_AccountUnlockingCoinsResponse>

  func accountLockedCoins(
    _ request: Osmosis_Lockup_AccountLockedCoinsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedCoinsRequest, Osmosis_Lockup_AccountLockedCoinsResponse>

  func accountLockedPastTime(
    _ request: Osmosis_Lockup_AccountLockedPastTimeRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedPastTimeRequest, Osmosis_Lockup_AccountLockedPastTimeResponse>

  func accountLockedPastTimeNotUnlockingOnly(
    _ request: Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyResponse>

  func accountUnlockedBeforeTime(
    _ request: Osmosis_Lockup_AccountUnlockedBeforeTimeRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountUnlockedBeforeTimeRequest, Osmosis_Lockup_AccountUnlockedBeforeTimeResponse>

  func accountLockedPastTimeDenom(
    _ request: Osmosis_Lockup_AccountLockedPastTimeDenomRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedPastTimeDenomRequest, Osmosis_Lockup_AccountLockedPastTimeDenomResponse>

  func lockedDenom(
    _ request: Osmosis_Lockup_LockedDenomRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_LockedDenomRequest, Osmosis_Lockup_LockedDenomResponse>

  func lockedByID(
    _ request: Osmosis_Lockup_LockedRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_LockedRequest, Osmosis_Lockup_LockedResponse>

  func syntheticLockupsByLockupID(
    _ request: Osmosis_Lockup_SyntheticLockupsByLockupIDRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_SyntheticLockupsByLockupIDRequest, Osmosis_Lockup_SyntheticLockupsByLockupIDResponse>

  func accountLockedLongerDuration(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedLongerDurationRequest, Osmosis_Lockup_AccountLockedLongerDurationResponse>

  func accountLockedDuration(
    _ request: Osmosis_Lockup_AccountLockedDurationRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedDurationRequest, Osmosis_Lockup_AccountLockedDurationResponse>

  func accountLockedLongerDurationNotUnlockingOnly(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyResponse>

  func accountLockedLongerDurationDenom(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationDenomRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedLongerDurationDenomRequest, Osmosis_Lockup_AccountLockedLongerDurationDenomResponse>
}

extension Osmosis_Lockup_QueryClientProtocol {
  public var serviceName: String {
    return "osmosis.lockup.Query"
  }

  /// Return full balance of the module
  ///
  /// - Parameters:
  ///   - request: Request to send to ModuleBalance.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func moduleBalance(
    _ request: Osmosis_Lockup_ModuleBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_ModuleBalanceRequest, Osmosis_Lockup_ModuleBalanceResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.moduleBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeModuleBalanceInterceptors() ?? []
    )
  }

  /// Return locked balance of the module
  ///
  /// - Parameters:
  ///   - request: Request to send to ModuleLockedAmount.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func moduleLockedAmount(
    _ request: Osmosis_Lockup_ModuleLockedAmountRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_ModuleLockedAmountRequest, Osmosis_Lockup_ModuleLockedAmountResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.moduleLockedAmount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeModuleLockedAmountInterceptors() ?? []
    )
  }

  /// Returns unlockable coins which are not withdrawn yet
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountUnlockableCoins.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountUnlockableCoins(
    _ request: Osmosis_Lockup_AccountUnlockableCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountUnlockableCoinsRequest, Osmosis_Lockup_AccountUnlockableCoinsResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockableCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockableCoinsInterceptors() ?? []
    )
  }

  /// Returns unlocking coins
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountUnlockingCoins.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountUnlockingCoins(
    _ request: Osmosis_Lockup_AccountUnlockingCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountUnlockingCoinsRequest, Osmosis_Lockup_AccountUnlockingCoinsResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockingCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockingCoinsInterceptors() ?? []
    )
  }

  /// Return a locked coins that can't be withdrawn
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountLockedCoins.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountLockedCoins(
    _ request: Osmosis_Lockup_AccountLockedCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedCoinsRequest, Osmosis_Lockup_AccountLockedCoinsResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedCoinsInterceptors() ?? []
    )
  }

  /// Returns locked records of an account with unlock time beyond timestamp
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountLockedPastTime.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountLockedPastTime(
    _ request: Osmosis_Lockup_AccountLockedPastTimeRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedPastTimeRequest, Osmosis_Lockup_AccountLockedPastTimeResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTime.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeInterceptors() ?? []
    )
  }

  /// Returns locked records of an account with unlock time beyond timestamp
  /// excluding tokens started unlocking
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountLockedPastTimeNotUnlockingOnly.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountLockedPastTimeNotUnlockingOnly(
    _ request: Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeNotUnlockingOnly.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeNotUnlockingOnlyInterceptors() ?? []
    )
  }

  /// Returns unlocked records with unlock time before timestamp
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountUnlockedBeforeTime.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountUnlockedBeforeTime(
    _ request: Osmosis_Lockup_AccountUnlockedBeforeTimeRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountUnlockedBeforeTimeRequest, Osmosis_Lockup_AccountUnlockedBeforeTimeResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockedBeforeTime.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockedBeforeTimeInterceptors() ?? []
    )
  }

  /// Returns lock records by address, timestamp, denom
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountLockedPastTimeDenom.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountLockedPastTimeDenom(
    _ request: Osmosis_Lockup_AccountLockedPastTimeDenomRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedPastTimeDenomRequest, Osmosis_Lockup_AccountLockedPastTimeDenomResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeDenomInterceptors() ?? []
    )
  }

  /// Returns total locked per denom with longer past given time
  ///
  /// - Parameters:
  ///   - request: Request to send to LockedDenom.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func lockedDenom(
    _ request: Osmosis_Lockup_LockedDenomRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_LockedDenomRequest, Osmosis_Lockup_LockedDenomResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.lockedDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLockedDenomInterceptors() ?? []
    )
  }

  /// Returns lock record by id
  ///
  /// - Parameters:
  ///   - request: Request to send to LockedByID.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func lockedByID(
    _ request: Osmosis_Lockup_LockedRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_LockedRequest, Osmosis_Lockup_LockedResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.lockedByID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLockedByIDInterceptors() ?? []
    )
  }

  /// Returns synthetic lockups by native lockup id
  ///
  /// - Parameters:
  ///   - request: Request to send to SyntheticLockupsByLockupID.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func syntheticLockupsByLockupID(
    _ request: Osmosis_Lockup_SyntheticLockupsByLockupIDRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_SyntheticLockupsByLockupIDRequest, Osmosis_Lockup_SyntheticLockupsByLockupIDResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.syntheticLockupsByLockupID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSyntheticLockupsByLockupIDInterceptors() ?? []
    )
  }

  /// Returns account locked records with longer duration
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountLockedLongerDuration.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountLockedLongerDuration(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedLongerDurationRequest, Osmosis_Lockup_AccountLockedLongerDurationResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDuration.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationInterceptors() ?? []
    )
  }

  /// Returns account locked records with a specific duration
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountLockedDuration.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountLockedDuration(
    _ request: Osmosis_Lockup_AccountLockedDurationRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedDurationRequest, Osmosis_Lockup_AccountLockedDurationResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedDuration.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedDurationInterceptors() ?? []
    )
  }

  /// Returns account locked records with longer duration excluding tokens
  /// started unlocking
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountLockedLongerDurationNotUnlockingOnly.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountLockedLongerDurationNotUnlockingOnly(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationNotUnlockingOnly.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationNotUnlockingOnlyInterceptors() ?? []
    )
  }

  /// Returns account's locked records for a denom with longer duration
  ///
  /// - Parameters:
  ///   - request: Request to send to AccountLockedLongerDurationDenom.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func accountLockedLongerDurationDenom(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationDenomRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Osmosis_Lockup_AccountLockedLongerDurationDenomRequest, Osmosis_Lockup_AccountLockedLongerDurationDenomResponse> {
    return self.makeUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationDenomInterceptors() ?? []
    )
  }
}

#if compiler(>=5.6)
@available(*, deprecated)
extension Osmosis_Lockup_QueryClient: @unchecked Sendable {}
#endif // compiler(>=5.6)

@available(*, deprecated, renamed: "Osmosis_Lockup_QueryNIOClient")
public final class Osmosis_Lockup_QueryClient: Osmosis_Lockup_QueryClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the osmosis.lockup.Query service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Osmosis_Lockup_QueryNIOClient: Osmosis_Lockup_QueryClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol?

  /// Creates a client for the osmosis.lockup.Query service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#if compiler(>=5.6)
/// Query defines the gRPC querier service.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Osmosis_Lockup_QueryAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol? { get }

  func makeModuleBalanceCall(
    _ request: Osmosis_Lockup_ModuleBalanceRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_ModuleBalanceRequest, Osmosis_Lockup_ModuleBalanceResponse>

  func makeModuleLockedAmountCall(
    _ request: Osmosis_Lockup_ModuleLockedAmountRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_ModuleLockedAmountRequest, Osmosis_Lockup_ModuleLockedAmountResponse>

  func makeAccountUnlockableCoinsCall(
    _ request: Osmosis_Lockup_AccountUnlockableCoinsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountUnlockableCoinsRequest, Osmosis_Lockup_AccountUnlockableCoinsResponse>

  func makeAccountUnlockingCoinsCall(
    _ request: Osmosis_Lockup_AccountUnlockingCoinsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountUnlockingCoinsRequest, Osmosis_Lockup_AccountUnlockingCoinsResponse>

  func makeAccountLockedCoinsCall(
    _ request: Osmosis_Lockup_AccountLockedCoinsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedCoinsRequest, Osmosis_Lockup_AccountLockedCoinsResponse>

  func makeAccountLockedPastTimeCall(
    _ request: Osmosis_Lockup_AccountLockedPastTimeRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedPastTimeRequest, Osmosis_Lockup_AccountLockedPastTimeResponse>

  func makeAccountLockedPastTimeNotUnlockingOnlyCall(
    _ request: Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyResponse>

  func makeAccountUnlockedBeforeTimeCall(
    _ request: Osmosis_Lockup_AccountUnlockedBeforeTimeRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountUnlockedBeforeTimeRequest, Osmosis_Lockup_AccountUnlockedBeforeTimeResponse>

  func makeAccountLockedPastTimeDenomCall(
    _ request: Osmosis_Lockup_AccountLockedPastTimeDenomRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedPastTimeDenomRequest, Osmosis_Lockup_AccountLockedPastTimeDenomResponse>

  func makeLockedDenomCall(
    _ request: Osmosis_Lockup_LockedDenomRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_LockedDenomRequest, Osmosis_Lockup_LockedDenomResponse>

  func makeLockedByIDCall(
    _ request: Osmosis_Lockup_LockedRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_LockedRequest, Osmosis_Lockup_LockedResponse>

  func makeSyntheticLockupsByLockupIDCall(
    _ request: Osmosis_Lockup_SyntheticLockupsByLockupIDRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_SyntheticLockupsByLockupIDRequest, Osmosis_Lockup_SyntheticLockupsByLockupIDResponse>

  func makeAccountLockedLongerDurationCall(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedLongerDurationRequest, Osmosis_Lockup_AccountLockedLongerDurationResponse>

  func makeAccountLockedDurationCall(
    _ request: Osmosis_Lockup_AccountLockedDurationRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedDurationRequest, Osmosis_Lockup_AccountLockedDurationResponse>

  func makeAccountLockedLongerDurationNotUnlockingOnlyCall(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyResponse>

  func makeAccountLockedLongerDurationDenomCall(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationDenomRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedLongerDurationDenomRequest, Osmosis_Lockup_AccountLockedLongerDurationDenomResponse>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Osmosis_Lockup_QueryAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Osmosis_Lockup_QueryClientMetadata.serviceDescriptor
  }

  public var interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeModuleBalanceCall(
    _ request: Osmosis_Lockup_ModuleBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_ModuleBalanceRequest, Osmosis_Lockup_ModuleBalanceResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.moduleBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeModuleBalanceInterceptors() ?? []
    )
  }

  public func makeModuleLockedAmountCall(
    _ request: Osmosis_Lockup_ModuleLockedAmountRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_ModuleLockedAmountRequest, Osmosis_Lockup_ModuleLockedAmountResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.moduleLockedAmount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeModuleLockedAmountInterceptors() ?? []
    )
  }

  public func makeAccountUnlockableCoinsCall(
    _ request: Osmosis_Lockup_AccountUnlockableCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountUnlockableCoinsRequest, Osmosis_Lockup_AccountUnlockableCoinsResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockableCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockableCoinsInterceptors() ?? []
    )
  }

  public func makeAccountUnlockingCoinsCall(
    _ request: Osmosis_Lockup_AccountUnlockingCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountUnlockingCoinsRequest, Osmosis_Lockup_AccountUnlockingCoinsResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockingCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockingCoinsInterceptors() ?? []
    )
  }

  public func makeAccountLockedCoinsCall(
    _ request: Osmosis_Lockup_AccountLockedCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedCoinsRequest, Osmosis_Lockup_AccountLockedCoinsResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedCoinsInterceptors() ?? []
    )
  }

  public func makeAccountLockedPastTimeCall(
    _ request: Osmosis_Lockup_AccountLockedPastTimeRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedPastTimeRequest, Osmosis_Lockup_AccountLockedPastTimeResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTime.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeInterceptors() ?? []
    )
  }

  public func makeAccountLockedPastTimeNotUnlockingOnlyCall(
    _ request: Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeNotUnlockingOnly.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeNotUnlockingOnlyInterceptors() ?? []
    )
  }

  public func makeAccountUnlockedBeforeTimeCall(
    _ request: Osmosis_Lockup_AccountUnlockedBeforeTimeRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountUnlockedBeforeTimeRequest, Osmosis_Lockup_AccountUnlockedBeforeTimeResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockedBeforeTime.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockedBeforeTimeInterceptors() ?? []
    )
  }

  public func makeAccountLockedPastTimeDenomCall(
    _ request: Osmosis_Lockup_AccountLockedPastTimeDenomRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedPastTimeDenomRequest, Osmosis_Lockup_AccountLockedPastTimeDenomResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeDenomInterceptors() ?? []
    )
  }

  public func makeLockedDenomCall(
    _ request: Osmosis_Lockup_LockedDenomRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_LockedDenomRequest, Osmosis_Lockup_LockedDenomResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.lockedDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLockedDenomInterceptors() ?? []
    )
  }

  public func makeLockedByIDCall(
    _ request: Osmosis_Lockup_LockedRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_LockedRequest, Osmosis_Lockup_LockedResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.lockedByID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLockedByIDInterceptors() ?? []
    )
  }

  public func makeSyntheticLockupsByLockupIDCall(
    _ request: Osmosis_Lockup_SyntheticLockupsByLockupIDRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_SyntheticLockupsByLockupIDRequest, Osmosis_Lockup_SyntheticLockupsByLockupIDResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.syntheticLockupsByLockupID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSyntheticLockupsByLockupIDInterceptors() ?? []
    )
  }

  public func makeAccountLockedLongerDurationCall(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedLongerDurationRequest, Osmosis_Lockup_AccountLockedLongerDurationResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDuration.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationInterceptors() ?? []
    )
  }

  public func makeAccountLockedDurationCall(
    _ request: Osmosis_Lockup_AccountLockedDurationRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedDurationRequest, Osmosis_Lockup_AccountLockedDurationResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedDuration.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedDurationInterceptors() ?? []
    )
  }

  public func makeAccountLockedLongerDurationNotUnlockingOnlyCall(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationNotUnlockingOnly.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationNotUnlockingOnlyInterceptors() ?? []
    )
  }

  public func makeAccountLockedLongerDurationDenomCall(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationDenomRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Osmosis_Lockup_AccountLockedLongerDurationDenomRequest, Osmosis_Lockup_AccountLockedLongerDurationDenomResponse> {
    return self.makeAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationDenomInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Osmosis_Lockup_QueryAsyncClientProtocol {
  public func moduleBalance(
    _ request: Osmosis_Lockup_ModuleBalanceRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_ModuleBalanceResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.moduleBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeModuleBalanceInterceptors() ?? []
    )
  }

  public func moduleLockedAmount(
    _ request: Osmosis_Lockup_ModuleLockedAmountRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_ModuleLockedAmountResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.moduleLockedAmount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeModuleLockedAmountInterceptors() ?? []
    )
  }

  public func accountUnlockableCoins(
    _ request: Osmosis_Lockup_AccountUnlockableCoinsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountUnlockableCoinsResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockableCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockableCoinsInterceptors() ?? []
    )
  }

  public func accountUnlockingCoins(
    _ request: Osmosis_Lockup_AccountUnlockingCoinsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountUnlockingCoinsResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockingCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockingCoinsInterceptors() ?? []
    )
  }

  public func accountLockedCoins(
    _ request: Osmosis_Lockup_AccountLockedCoinsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountLockedCoinsResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedCoinsInterceptors() ?? []
    )
  }

  public func accountLockedPastTime(
    _ request: Osmosis_Lockup_AccountLockedPastTimeRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountLockedPastTimeResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTime.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeInterceptors() ?? []
    )
  }

  public func accountLockedPastTimeNotUnlockingOnly(
    _ request: Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeNotUnlockingOnly.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeNotUnlockingOnlyInterceptors() ?? []
    )
  }

  public func accountUnlockedBeforeTime(
    _ request: Osmosis_Lockup_AccountUnlockedBeforeTimeRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountUnlockedBeforeTimeResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockedBeforeTime.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountUnlockedBeforeTimeInterceptors() ?? []
    )
  }

  public func accountLockedPastTimeDenom(
    _ request: Osmosis_Lockup_AccountLockedPastTimeDenomRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountLockedPastTimeDenomResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedPastTimeDenomInterceptors() ?? []
    )
  }

  public func lockedDenom(
    _ request: Osmosis_Lockup_LockedDenomRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_LockedDenomResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.lockedDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLockedDenomInterceptors() ?? []
    )
  }

  public func lockedByID(
    _ request: Osmosis_Lockup_LockedRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_LockedResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.lockedByID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLockedByIDInterceptors() ?? []
    )
  }

  public func syntheticLockupsByLockupID(
    _ request: Osmosis_Lockup_SyntheticLockupsByLockupIDRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_SyntheticLockupsByLockupIDResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.syntheticLockupsByLockupID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSyntheticLockupsByLockupIDInterceptors() ?? []
    )
  }

  public func accountLockedLongerDuration(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountLockedLongerDurationResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDuration.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationInterceptors() ?? []
    )
  }

  public func accountLockedDuration(
    _ request: Osmosis_Lockup_AccountLockedDurationRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountLockedDurationResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedDuration.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedDurationInterceptors() ?? []
    )
  }

  public func accountLockedLongerDurationNotUnlockingOnly(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationNotUnlockingOnly.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationNotUnlockingOnlyInterceptors() ?? []
    )
  }

  public func accountLockedLongerDurationDenom(
    _ request: Osmosis_Lockup_AccountLockedLongerDurationDenomRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Osmosis_Lockup_AccountLockedLongerDurationDenomResponse {
    return try await self.performAsyncUnaryCall(
      path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationDenom.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAccountLockedLongerDurationDenomInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Osmosis_Lockup_QueryAsyncClient: Osmosis_Lockup_QueryAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#endif // compiler(>=5.6)

public protocol Osmosis_Lockup_QueryClientInterceptorFactoryProtocol: GRPCSendable {

  /// - Returns: Interceptors to use when invoking 'moduleBalance'.
  func makeModuleBalanceInterceptors() -> [ClientInterceptor<Osmosis_Lockup_ModuleBalanceRequest, Osmosis_Lockup_ModuleBalanceResponse>]

  /// - Returns: Interceptors to use when invoking 'moduleLockedAmount'.
  func makeModuleLockedAmountInterceptors() -> [ClientInterceptor<Osmosis_Lockup_ModuleLockedAmountRequest, Osmosis_Lockup_ModuleLockedAmountResponse>]

  /// - Returns: Interceptors to use when invoking 'accountUnlockableCoins'.
  func makeAccountUnlockableCoinsInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountUnlockableCoinsRequest, Osmosis_Lockup_AccountUnlockableCoinsResponse>]

  /// - Returns: Interceptors to use when invoking 'accountUnlockingCoins'.
  func makeAccountUnlockingCoinsInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountUnlockingCoinsRequest, Osmosis_Lockup_AccountUnlockingCoinsResponse>]

  /// - Returns: Interceptors to use when invoking 'accountLockedCoins'.
  func makeAccountLockedCoinsInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountLockedCoinsRequest, Osmosis_Lockup_AccountLockedCoinsResponse>]

  /// - Returns: Interceptors to use when invoking 'accountLockedPastTime'.
  func makeAccountLockedPastTimeInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountLockedPastTimeRequest, Osmosis_Lockup_AccountLockedPastTimeResponse>]

  /// - Returns: Interceptors to use when invoking 'accountLockedPastTimeNotUnlockingOnly'.
  func makeAccountLockedPastTimeNotUnlockingOnlyInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyResponse>]

  /// - Returns: Interceptors to use when invoking 'accountUnlockedBeforeTime'.
  func makeAccountUnlockedBeforeTimeInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountUnlockedBeforeTimeRequest, Osmosis_Lockup_AccountUnlockedBeforeTimeResponse>]

  /// - Returns: Interceptors to use when invoking 'accountLockedPastTimeDenom'.
  func makeAccountLockedPastTimeDenomInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountLockedPastTimeDenomRequest, Osmosis_Lockup_AccountLockedPastTimeDenomResponse>]

  /// - Returns: Interceptors to use when invoking 'lockedDenom'.
  func makeLockedDenomInterceptors() -> [ClientInterceptor<Osmosis_Lockup_LockedDenomRequest, Osmosis_Lockup_LockedDenomResponse>]

  /// - Returns: Interceptors to use when invoking 'lockedByID'.
  func makeLockedByIDInterceptors() -> [ClientInterceptor<Osmosis_Lockup_LockedRequest, Osmosis_Lockup_LockedResponse>]

  /// - Returns: Interceptors to use when invoking 'syntheticLockupsByLockupID'.
  func makeSyntheticLockupsByLockupIDInterceptors() -> [ClientInterceptor<Osmosis_Lockup_SyntheticLockupsByLockupIDRequest, Osmosis_Lockup_SyntheticLockupsByLockupIDResponse>]

  /// - Returns: Interceptors to use when invoking 'accountLockedLongerDuration'.
  func makeAccountLockedLongerDurationInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountLockedLongerDurationRequest, Osmosis_Lockup_AccountLockedLongerDurationResponse>]

  /// - Returns: Interceptors to use when invoking 'accountLockedDuration'.
  func makeAccountLockedDurationInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountLockedDurationRequest, Osmosis_Lockup_AccountLockedDurationResponse>]

  /// - Returns: Interceptors to use when invoking 'accountLockedLongerDurationNotUnlockingOnly'.
  func makeAccountLockedLongerDurationNotUnlockingOnlyInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyResponse>]

  /// - Returns: Interceptors to use when invoking 'accountLockedLongerDurationDenom'.
  func makeAccountLockedLongerDurationDenomInterceptors() -> [ClientInterceptor<Osmosis_Lockup_AccountLockedLongerDurationDenomRequest, Osmosis_Lockup_AccountLockedLongerDurationDenomResponse>]
}

public enum Osmosis_Lockup_QueryClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Query",
    fullName: "osmosis.lockup.Query",
    methods: [
      Osmosis_Lockup_QueryClientMetadata.Methods.moduleBalance,
      Osmosis_Lockup_QueryClientMetadata.Methods.moduleLockedAmount,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockableCoins,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockingCoins,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedCoins,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTime,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeNotUnlockingOnly,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockedBeforeTime,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeDenom,
      Osmosis_Lockup_QueryClientMetadata.Methods.lockedDenom,
      Osmosis_Lockup_QueryClientMetadata.Methods.lockedByID,
      Osmosis_Lockup_QueryClientMetadata.Methods.syntheticLockupsByLockupID,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDuration,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedDuration,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationNotUnlockingOnly,
      Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationDenom,
    ]
  )

  public enum Methods {
    public static let moduleBalance = GRPCMethodDescriptor(
      name: "ModuleBalance",
      path: "/osmosis.lockup.Query/ModuleBalance",
      type: GRPCCallType.unary
    )

    public static let moduleLockedAmount = GRPCMethodDescriptor(
      name: "ModuleLockedAmount",
      path: "/osmosis.lockup.Query/ModuleLockedAmount",
      type: GRPCCallType.unary
    )

    public static let accountUnlockableCoins = GRPCMethodDescriptor(
      name: "AccountUnlockableCoins",
      path: "/osmosis.lockup.Query/AccountUnlockableCoins",
      type: GRPCCallType.unary
    )

    public static let accountUnlockingCoins = GRPCMethodDescriptor(
      name: "AccountUnlockingCoins",
      path: "/osmosis.lockup.Query/AccountUnlockingCoins",
      type: GRPCCallType.unary
    )

    public static let accountLockedCoins = GRPCMethodDescriptor(
      name: "AccountLockedCoins",
      path: "/osmosis.lockup.Query/AccountLockedCoins",
      type: GRPCCallType.unary
    )

    public static let accountLockedPastTime = GRPCMethodDescriptor(
      name: "AccountLockedPastTime",
      path: "/osmosis.lockup.Query/AccountLockedPastTime",
      type: GRPCCallType.unary
    )

    public static let accountLockedPastTimeNotUnlockingOnly = GRPCMethodDescriptor(
      name: "AccountLockedPastTimeNotUnlockingOnly",
      path: "/osmosis.lockup.Query/AccountLockedPastTimeNotUnlockingOnly",
      type: GRPCCallType.unary
    )

    public static let accountUnlockedBeforeTime = GRPCMethodDescriptor(
      name: "AccountUnlockedBeforeTime",
      path: "/osmosis.lockup.Query/AccountUnlockedBeforeTime",
      type: GRPCCallType.unary
    )

    public static let accountLockedPastTimeDenom = GRPCMethodDescriptor(
      name: "AccountLockedPastTimeDenom",
      path: "/osmosis.lockup.Query/AccountLockedPastTimeDenom",
      type: GRPCCallType.unary
    )

    public static let lockedDenom = GRPCMethodDescriptor(
      name: "LockedDenom",
      path: "/osmosis.lockup.Query/LockedDenom",
      type: GRPCCallType.unary
    )

    public static let lockedByID = GRPCMethodDescriptor(
      name: "LockedByID",
      path: "/osmosis.lockup.Query/LockedByID",
      type: GRPCCallType.unary
    )

    public static let syntheticLockupsByLockupID = GRPCMethodDescriptor(
      name: "SyntheticLockupsByLockupID",
      path: "/osmosis.lockup.Query/SyntheticLockupsByLockupID",
      type: GRPCCallType.unary
    )

    public static let accountLockedLongerDuration = GRPCMethodDescriptor(
      name: "AccountLockedLongerDuration",
      path: "/osmosis.lockup.Query/AccountLockedLongerDuration",
      type: GRPCCallType.unary
    )

    public static let accountLockedDuration = GRPCMethodDescriptor(
      name: "AccountLockedDuration",
      path: "/osmosis.lockup.Query/AccountLockedDuration",
      type: GRPCCallType.unary
    )

    public static let accountLockedLongerDurationNotUnlockingOnly = GRPCMethodDescriptor(
      name: "AccountLockedLongerDurationNotUnlockingOnly",
      path: "/osmosis.lockup.Query/AccountLockedLongerDurationNotUnlockingOnly",
      type: GRPCCallType.unary
    )

    public static let accountLockedLongerDurationDenom = GRPCMethodDescriptor(
      name: "AccountLockedLongerDurationDenom",
      path: "/osmosis.lockup.Query/AccountLockedLongerDurationDenom",
      type: GRPCCallType.unary
    )
  }
}

#if compiler(>=5.6)
@available(swift, deprecated: 5.6)
extension Osmosis_Lockup_QueryTestClient: @unchecked Sendable {}
#endif // compiler(>=5.6)

@available(swift, deprecated: 5.6, message: "Test clients are not Sendable but the 'GRPCClient' API requires clients to be Sendable. Using a localhost client and server is the recommended alternative.")
public final class Osmosis_Lockup_QueryTestClient: Osmosis_Lockup_QueryClientProtocol {
  private let fakeChannel: FakeChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol?

  public var channel: GRPCChannel {
    return self.fakeChannel
  }

  public init(
    fakeChannel: FakeChannel = FakeChannel(),
    defaultCallOptions callOptions: CallOptions = CallOptions(),
    interceptors: Osmosis_Lockup_QueryClientInterceptorFactoryProtocol? = nil
  ) {
    self.fakeChannel = fakeChannel
    self.defaultCallOptions = callOptions
    self.interceptors = interceptors
  }

  /// Make a unary response for the ModuleBalance RPC. This must be called
  /// before calling 'moduleBalance'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeModuleBalanceResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_ModuleBalanceRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_ModuleBalanceRequest, Osmosis_Lockup_ModuleBalanceResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.moduleBalance.path, requestHandler: requestHandler)
  }

  public func enqueueModuleBalanceResponse(
    _ response: Osmosis_Lockup_ModuleBalanceResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_ModuleBalanceRequest>) -> () = { _ in }
  ) {
    let stream = self.makeModuleBalanceResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'ModuleBalance'
  public var hasModuleBalanceResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.moduleBalance.path)
  }

  /// Make a unary response for the ModuleLockedAmount RPC. This must be called
  /// before calling 'moduleLockedAmount'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeModuleLockedAmountResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_ModuleLockedAmountRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_ModuleLockedAmountRequest, Osmosis_Lockup_ModuleLockedAmountResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.moduleLockedAmount.path, requestHandler: requestHandler)
  }

  public func enqueueModuleLockedAmountResponse(
    _ response: Osmosis_Lockup_ModuleLockedAmountResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_ModuleLockedAmountRequest>) -> () = { _ in }
  ) {
    let stream = self.makeModuleLockedAmountResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'ModuleLockedAmount'
  public var hasModuleLockedAmountResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.moduleLockedAmount.path)
  }

  /// Make a unary response for the AccountUnlockableCoins RPC. This must be called
  /// before calling 'accountUnlockableCoins'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountUnlockableCoinsResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountUnlockableCoinsRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountUnlockableCoinsRequest, Osmosis_Lockup_AccountUnlockableCoinsResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockableCoins.path, requestHandler: requestHandler)
  }

  public func enqueueAccountUnlockableCoinsResponse(
    _ response: Osmosis_Lockup_AccountUnlockableCoinsResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountUnlockableCoinsRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountUnlockableCoinsResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountUnlockableCoins'
  public var hasAccountUnlockableCoinsResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockableCoins.path)
  }

  /// Make a unary response for the AccountUnlockingCoins RPC. This must be called
  /// before calling 'accountUnlockingCoins'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountUnlockingCoinsResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountUnlockingCoinsRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountUnlockingCoinsRequest, Osmosis_Lockup_AccountUnlockingCoinsResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockingCoins.path, requestHandler: requestHandler)
  }

  public func enqueueAccountUnlockingCoinsResponse(
    _ response: Osmosis_Lockup_AccountUnlockingCoinsResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountUnlockingCoinsRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountUnlockingCoinsResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountUnlockingCoins'
  public var hasAccountUnlockingCoinsResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockingCoins.path)
  }

  /// Make a unary response for the AccountLockedCoins RPC. This must be called
  /// before calling 'accountLockedCoins'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountLockedCoinsResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedCoinsRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountLockedCoinsRequest, Osmosis_Lockup_AccountLockedCoinsResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedCoins.path, requestHandler: requestHandler)
  }

  public func enqueueAccountLockedCoinsResponse(
    _ response: Osmosis_Lockup_AccountLockedCoinsResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedCoinsRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountLockedCoinsResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountLockedCoins'
  public var hasAccountLockedCoinsResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedCoins.path)
  }

  /// Make a unary response for the AccountLockedPastTime RPC. This must be called
  /// before calling 'accountLockedPastTime'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountLockedPastTimeResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedPastTimeRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountLockedPastTimeRequest, Osmosis_Lockup_AccountLockedPastTimeResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTime.path, requestHandler: requestHandler)
  }

  public func enqueueAccountLockedPastTimeResponse(
    _ response: Osmosis_Lockup_AccountLockedPastTimeResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedPastTimeRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountLockedPastTimeResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountLockedPastTime'
  public var hasAccountLockedPastTimeResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTime.path)
  }

  /// Make a unary response for the AccountLockedPastTimeNotUnlockingOnly RPC. This must be called
  /// before calling 'accountLockedPastTimeNotUnlockingOnly'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountLockedPastTimeNotUnlockingOnlyResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeNotUnlockingOnly.path, requestHandler: requestHandler)
  }

  public func enqueueAccountLockedPastTimeNotUnlockingOnlyResponse(
    _ response: Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedPastTimeNotUnlockingOnlyRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountLockedPastTimeNotUnlockingOnlyResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountLockedPastTimeNotUnlockingOnly'
  public var hasAccountLockedPastTimeNotUnlockingOnlyResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeNotUnlockingOnly.path)
  }

  /// Make a unary response for the AccountUnlockedBeforeTime RPC. This must be called
  /// before calling 'accountUnlockedBeforeTime'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountUnlockedBeforeTimeResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountUnlockedBeforeTimeRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountUnlockedBeforeTimeRequest, Osmosis_Lockup_AccountUnlockedBeforeTimeResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockedBeforeTime.path, requestHandler: requestHandler)
  }

  public func enqueueAccountUnlockedBeforeTimeResponse(
    _ response: Osmosis_Lockup_AccountUnlockedBeforeTimeResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountUnlockedBeforeTimeRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountUnlockedBeforeTimeResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountUnlockedBeforeTime'
  public var hasAccountUnlockedBeforeTimeResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountUnlockedBeforeTime.path)
  }

  /// Make a unary response for the AccountLockedPastTimeDenom RPC. This must be called
  /// before calling 'accountLockedPastTimeDenom'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountLockedPastTimeDenomResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedPastTimeDenomRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountLockedPastTimeDenomRequest, Osmosis_Lockup_AccountLockedPastTimeDenomResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeDenom.path, requestHandler: requestHandler)
  }

  public func enqueueAccountLockedPastTimeDenomResponse(
    _ response: Osmosis_Lockup_AccountLockedPastTimeDenomResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedPastTimeDenomRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountLockedPastTimeDenomResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountLockedPastTimeDenom'
  public var hasAccountLockedPastTimeDenomResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedPastTimeDenom.path)
  }

  /// Make a unary response for the LockedDenom RPC. This must be called
  /// before calling 'lockedDenom'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeLockedDenomResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_LockedDenomRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_LockedDenomRequest, Osmosis_Lockup_LockedDenomResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.lockedDenom.path, requestHandler: requestHandler)
  }

  public func enqueueLockedDenomResponse(
    _ response: Osmosis_Lockup_LockedDenomResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_LockedDenomRequest>) -> () = { _ in }
  ) {
    let stream = self.makeLockedDenomResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'LockedDenom'
  public var hasLockedDenomResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.lockedDenom.path)
  }

  /// Make a unary response for the LockedByID RPC. This must be called
  /// before calling 'lockedByID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeLockedByIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_LockedRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_LockedRequest, Osmosis_Lockup_LockedResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.lockedByID.path, requestHandler: requestHandler)
  }

  public func enqueueLockedByIDResponse(
    _ response: Osmosis_Lockup_LockedResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_LockedRequest>) -> () = { _ in }
  ) {
    let stream = self.makeLockedByIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'LockedByID'
  public var hasLockedByIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.lockedByID.path)
  }

  /// Make a unary response for the SyntheticLockupsByLockupID RPC. This must be called
  /// before calling 'syntheticLockupsByLockupID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeSyntheticLockupsByLockupIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_SyntheticLockupsByLockupIDRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_SyntheticLockupsByLockupIDRequest, Osmosis_Lockup_SyntheticLockupsByLockupIDResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.syntheticLockupsByLockupID.path, requestHandler: requestHandler)
  }

  public func enqueueSyntheticLockupsByLockupIDResponse(
    _ response: Osmosis_Lockup_SyntheticLockupsByLockupIDResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_SyntheticLockupsByLockupIDRequest>) -> () = { _ in }
  ) {
    let stream = self.makeSyntheticLockupsByLockupIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'SyntheticLockupsByLockupID'
  public var hasSyntheticLockupsByLockupIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.syntheticLockupsByLockupID.path)
  }

  /// Make a unary response for the AccountLockedLongerDuration RPC. This must be called
  /// before calling 'accountLockedLongerDuration'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountLockedLongerDurationResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedLongerDurationRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountLockedLongerDurationRequest, Osmosis_Lockup_AccountLockedLongerDurationResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDuration.path, requestHandler: requestHandler)
  }

  public func enqueueAccountLockedLongerDurationResponse(
    _ response: Osmosis_Lockup_AccountLockedLongerDurationResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedLongerDurationRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountLockedLongerDurationResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountLockedLongerDuration'
  public var hasAccountLockedLongerDurationResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDuration.path)
  }

  /// Make a unary response for the AccountLockedDuration RPC. This must be called
  /// before calling 'accountLockedDuration'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountLockedDurationResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedDurationRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountLockedDurationRequest, Osmosis_Lockup_AccountLockedDurationResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedDuration.path, requestHandler: requestHandler)
  }

  public func enqueueAccountLockedDurationResponse(
    _ response: Osmosis_Lockup_AccountLockedDurationResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedDurationRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountLockedDurationResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountLockedDuration'
  public var hasAccountLockedDurationResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedDuration.path)
  }

  /// Make a unary response for the AccountLockedLongerDurationNotUnlockingOnly RPC. This must be called
  /// before calling 'accountLockedLongerDurationNotUnlockingOnly'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountLockedLongerDurationNotUnlockingOnlyResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest, Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationNotUnlockingOnly.path, requestHandler: requestHandler)
  }

  public func enqueueAccountLockedLongerDurationNotUnlockingOnlyResponse(
    _ response: Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedLongerDurationNotUnlockingOnlyRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountLockedLongerDurationNotUnlockingOnlyResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountLockedLongerDurationNotUnlockingOnly'
  public var hasAccountLockedLongerDurationNotUnlockingOnlyResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationNotUnlockingOnly.path)
  }

  /// Make a unary response for the AccountLockedLongerDurationDenom RPC. This must be called
  /// before calling 'accountLockedLongerDurationDenom'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  public func makeAccountLockedLongerDurationDenomResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedLongerDurationDenomRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Osmosis_Lockup_AccountLockedLongerDurationDenomRequest, Osmosis_Lockup_AccountLockedLongerDurationDenomResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationDenom.path, requestHandler: requestHandler)
  }

  public func enqueueAccountLockedLongerDurationDenomResponse(
    _ response: Osmosis_Lockup_AccountLockedLongerDurationDenomResponse,
    _ requestHandler: @escaping (FakeRequestPart<Osmosis_Lockup_AccountLockedLongerDurationDenomRequest>) -> () = { _ in }
  ) {
    let stream = self.makeAccountLockedLongerDurationDenomResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'AccountLockedLongerDurationDenom'
  public var hasAccountLockedLongerDurationDenomResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: Osmosis_Lockup_QueryClientMetadata.Methods.accountLockedLongerDurationDenom.path)
  }
}

